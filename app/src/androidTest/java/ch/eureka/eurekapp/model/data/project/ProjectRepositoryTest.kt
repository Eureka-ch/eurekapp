/* Portions of this file were written with the help of Gemini and Claude. */
package ch.eureka.eurekapp.model.data.project

import ch.eureka.eurekapp.model.data.meeting.Meeting
import ch.eureka.eurekapp.model.data.meeting.MeetingRole
import ch.eureka.eurekapp.model.data.meeting.MeetingStatus
import ch.eureka.eurekapp.model.data.meeting.Participant
import ch.eureka.eurekapp.utils.FirebaseEmulator
import ch.eureka.eurekapp.utils.FirestoreRepositoryTest
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FirebaseFirestoreException
import io.mockk.every
import io.mockk.mockk
import junit.framework.TestCase.assertEquals
import junit.framework.TestCase.assertNotNull
import junit.framework.TestCase.assertNull
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.tasks.await
import org.junit.Before
import org.junit.Test

/**
 * Test suite for ProjectRepository implementation.
 *
 * Note: Part of the code was generated by Claude Code and Gemini.
 */
class ProjectRepositoryTest : FirestoreRepositoryTest() {

  private lateinit var repository: ProjectRepository

  override fun getCollectionPaths(): List<String> {
    return listOf("projects")
  }

  @Before
  override fun setup() = runBlocking {
    super.setup()
    repository =
        FirestoreProjectRepository(
            firestore = FirebaseEmulator.firestore, auth = FirebaseEmulator.auth)
  }

  @Test
  fun projectRepository_createProjectShouldCreateProjectInFirestore() = runBlocking {
    val project =
        Project(
            projectId = "project1",
            name = "Test Project",
            description = "Test project description",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)

    val result = repository.createProject(project, testUserId, ProjectRole.OWNER)

    assertTrue(result.isSuccess)
    assertEquals("project1", result.getOrNull())

    val savedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project1")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNotNull(savedProject)
    assertEquals(project.projectId, savedProject?.projectId)
    assertEquals(project.name, savedProject?.name)
    assertEquals(project.description, savedProject?.description)
    assertEquals(project.status, savedProject?.status)

    val members = repository.getMembers("project1").first()
    assertEquals(1, members.size)
    assertEquals(testUserId, members[0].userId)
    assertEquals(ProjectRole.OWNER, members[0].role)
  }

  @Test
  fun projectRepository_getProjectByIdShouldReturnProjectWhenExists() = runBlocking {
    val project =
        Project(
            projectId = "project2",
            name = "Test Project 2",
            description = "Description 2",
            status = ProjectStatus.IN_PROGRESS,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.ADMIN)

    val flow = repository.getProjectById("project2")
    val retrievedProject = flow.first()

    assertNotNull(retrievedProject)
    assertEquals(project.projectId, retrievedProject?.projectId)
    assertEquals(project.name, retrievedProject?.name)
    assertEquals(project.status, retrievedProject?.status)
  }

  @Test
  fun projectRepository_getProjectByIdShouldReturnNullWhenProjectDoesNotExist() = runBlocking {
    val flow = repository.getProjectById("non_existent_project")
    val retrievedProject = flow.first()

    assertNull(retrievedProject)
  }

  @Test
  fun projectRepository_getProjectsForCurrentUserShouldReturnAllProjectsForUser() = runBlocking {
    val project1 =
        Project(
            projectId = "project3",
            name = "Project 3",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    val project2 =
        Project(
            projectId = "project4",
            name = "Project 4",
            description = "",
            status = ProjectStatus.COMPLETED,
            createdBy = testUserId)

    val createFirst = repository.createProject(project1, testUserId, ProjectRole.OWNER)
    val createSecond = repository.createProject(project2, testUserId, ProjectRole.MEMBER)
    assertTrue(createFirst.isSuccess && createSecond.isSuccess)
    val flow = repository.getProjectsForCurrentUser(skipCache = true)
    val projects = flow.first()

    assertEquals(2, projects.size)
    assertTrue(projects.any { it.projectId == "project3" })
    assertTrue(projects.any { it.projectId == "project4" })
  }

  @Test
  fun projectRepository_updateProjectShouldUpdateProjectDetails() = runBlocking {
    val project =
        Project(
            projectId = "project5",
            name = "Original Name",
            description = "Original Description",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    val updatedProject =
        project.copy(
            name = "Updated Name",
            description = "Updated Description",
            status = ProjectStatus.IN_PROGRESS)
    val result = repository.updateProject(updatedProject)

    assertTrue(result.isSuccess)

    val savedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project5")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNotNull(savedProject)
    assertEquals("Updated Name", savedProject?.name)
    assertEquals("Updated Description", savedProject?.description)
    assertEquals(ProjectStatus.IN_PROGRESS, savedProject?.status)
  }

  @Test
  fun projectRepository_deleteProjectShouldDeleteProjectFromFirestore() = runBlocking {
    val project =
        Project(
            projectId = "project6",
            name = "To Delete",
            description = "",
            status = ProjectStatus.ARCHIVED,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    val result = repository.deleteProject("project6")

    assertTrue(result.isSuccess)

    val deletedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project6")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNull(deletedProject)
  }

  @Test
  fun projectRepository_addMemberShouldAddMemberToProjectAndExistingMeetings() = runBlocking {
    val projectId = "project7"
    val project =
        Project(
            projectId = projectId,
            name = "Member Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    // Create an existing meeting in the project
    val meetingId = "meeting1"
    val meeting =
        Meeting(
            meetingID = meetingId,
            projectId = projectId,
            title = "Existing Meeting",
            status = MeetingStatus.SCHEDULED,
            createdBy = testUserId,
            participantIds = listOf(testUserId))
    FirebaseEmulator.firestore
        .collection("projects")
        .document(projectId)
        .collection("meetings")
        .document(meetingId)
        .set(meeting)
        .await()

    val newUserId = "test_user_2"
    val result = repository.addMember(projectId, newUserId, ProjectRole.MEMBER)

    assertTrue(result.isSuccess)

    // Check project membership
    val members = repository.getMembers(projectId).first()
    assertEquals(2, members.size)
    assertTrue(members.any { it.userId == newUserId && it.role == ProjectRole.MEMBER })

    // Check if added to existing meeting
    val updatedMeeting =
        FirebaseEmulator.firestore
            .collection("projects")
            .document(projectId)
            .collection("meetings")
            .document(meetingId)
            .get()
            .await()
            .toObject(Meeting::class.java)

    assertTrue(updatedMeeting?.participantIds?.contains(newUserId) == true)

    // Check if participant subcollection document created
    val participantDoc =
        FirebaseEmulator.firestore
            .collection("projects")
            .document(projectId)
            .collection("meetings")
            .document(meetingId)
            .collection("participants")
            .document(newUserId)
            .get()
            .await()
            .toObject(Participant::class.java)

    assertNotNull(participantDoc)
    assertEquals(newUserId, participantDoc?.userId)
  }

  @Test
  fun projectRepository_removeMemberShouldRemoveMemberFromProjectAndMeetings() = runBlocking {
    val projectId = "project8"
    val memberToRemove = "test_user_2"
    val project =
        Project(
            projectId = projectId,
            name = "Remove Member Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    // Create a meeting where the user is a participant
    val meetingId = "meeting2"
    val meeting =
        Meeting(
            meetingID = meetingId,
            projectId = projectId,
            title = "Existing Meeting",
            status = MeetingStatus.SCHEDULED,
            createdBy = testUserId,
            participantIds = listOf(testUserId, memberToRemove))
    FirebaseEmulator.firestore
        .collection("projects")
        .document(projectId)
        .collection("meetings")
        .document(meetingId)
        .set(meeting)
        .await()

    // Add participant sub-doc
    val participant = Participant(userId = memberToRemove, role = MeetingRole.PARTICIPANT)
    FirebaseEmulator.firestore
        .collection("projects")
        .document(projectId)
        .collection("meetings")
        .document(meetingId)
        .collection("participants")
        .document(memberToRemove)
        .set(participant)
        .await()

    // Add member to project first
    repository.addMember(projectId, memberToRemove, ProjectRole.MEMBER)

    val result = repository.removeMember(projectId, memberToRemove)

    assertTrue(result.isSuccess)

    val members = repository.getMembers(projectId).first()
    assertEquals(1, members.size)
    assertTrue(members.all { it.userId == testUserId })

    // Check removed from meeting array
    val updatedMeeting =
        FirebaseEmulator.firestore
            .collection("projects")
            .document(projectId)
            .collection("meetings")
            .document(meetingId)
            .get()
            .await()
            .toObject(Meeting::class.java)

    assertTrue(updatedMeeting?.participantIds?.contains(memberToRemove) == false)

    // Check participant doc deleted
    val participantDoc =
        FirebaseEmulator.firestore
            .collection("projects")
            .document(projectId)
            .collection("meetings")
            .document(meetingId)
            .collection("participants")
            .document(memberToRemove)
            .get()
            .await()

    assertTrue(!participantDoc.exists())
  }

  @Test
  fun projectRepository_updateMemberRoleShouldUpdateMemberRole() = runBlocking {
    val memberToUpdate = "test_user_2"
    val project =
        Project(
            projectId = "project9",
            name = "Update Role Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)
    repository.addMember("project9", memberToUpdate, ProjectRole.MEMBER)

    val result = repository.updateMemberRole("project9", memberToUpdate, ProjectRole.ADMIN)

    assertTrue(result.isSuccess)

    val members = repository.getMembers("project9").first()
    val updatedMember = members.find { it.userId == memberToUpdate }
    assertNotNull(updatedMember)
    assertEquals(ProjectRole.ADMIN, updatedMember?.role)

    val ownerMember = members.find { it.userId == testUserId }
    assertNotNull(ownerMember)
    assertEquals(ProjectRole.OWNER, ownerMember?.role)
  }

  @Test
  fun projectRepository_getProjectByIdShouldHandleSnapshotListenerError(): Unit = runBlocking {
    var caughtException: Throwable? = null

    val mockFirestore = mockk<FirebaseFirestore>(relaxed = true)
    val mockAuth = mockk<FirebaseAuth>(relaxed = true)
    every { mockFirestore.collection(any()) } throws
        FirebaseFirestoreException(
            "Simulated error", FirebaseFirestoreException.Code.PERMISSION_DENIED)

    val testRepository = FirestoreProjectRepository(mockFirestore, mockAuth)
    val flow = testRepository.getProjectById("test_project")

    try {
      flow.catch { exception -> caughtException = exception }.first()
    } catch (e: Exception) {
      caughtException = e
    }

    assertNotNull(caughtException)
  }

  @Test
  fun projectRepository_getMembersShouldHandleSnapshotListenerError(): Unit = runBlocking {
    var caughtException: Throwable? = null

    val mockFirestore = mockk<FirebaseFirestore>(relaxed = true)
    val mockAuth = mockk<FirebaseAuth>(relaxed = true)
    every { mockFirestore.collection(any()) } throws
        FirebaseFirestoreException(
            "Simulated error", FirebaseFirestoreException.Code.PERMISSION_DENIED)

    val testRepository = FirestoreProjectRepository(mockFirestore, mockAuth)
    val flow = testRepository.getMembers("test_project")

    try {
      flow.catch { exception -> caughtException = exception }.first()
    } catch (e: Exception) {
      caughtException = e
    }

    assertNotNull(caughtException)
  }
}
