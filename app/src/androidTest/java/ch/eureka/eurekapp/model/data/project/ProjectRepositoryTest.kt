package ch.eureka.eurekapp.model.data.project

import ch.eureka.eurekapp.utils.FirebaseEmulator
import ch.eureka.eurekapp.utils.FirestoreRepositoryTest
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.FirebaseFirestoreException
import io.mockk.every
import io.mockk.mockk
import junit.framework.TestCase.assertEquals
import junit.framework.TestCase.assertNotNull
import junit.framework.TestCase.assertNull
import junit.framework.TestCase.assertTrue
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.tasks.await
import org.junit.Before
import org.junit.Test

/**
 * Test suite for ProjectRepository implementation.
 *
 * Note: Part of the code was generated by Claude Code.
 */
class ProjectRepositoryTest : FirestoreRepositoryTest() {

  private lateinit var repository: ProjectRepository

  override fun getCollectionPaths(): List<String> {
    return listOf("projects")
  }

  @Before
  override fun setup() = runBlocking {
    super.setup()
    repository =
        FirestoreProjectRepository(
            firestore = FirebaseEmulator.firestore, auth = FirebaseEmulator.auth)
  }

  @Test
  fun createProject_shouldCreateProjectInFirestore() = runBlocking {
    val project =
        Project(
            projectId = "project1",
            name = "Test Project",
            description = "Test project description",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)

    val result = repository.createProject(project, testUserId, ProjectRole.OWNER)

    assertTrue(result.isSuccess)
    assertEquals("project1", result.getOrNull())

    val savedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project1")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNotNull(savedProject)
    assertEquals(project.projectId, savedProject?.projectId)
    assertEquals(project.name, savedProject?.name)
    assertEquals(project.description, savedProject?.description)
    assertEquals(project.status, savedProject?.status)

    val members = repository.getMembers("project1").first()
    assertEquals(1, members.size)
    assertEquals(testUserId, members[0].userId)
    assertEquals(ProjectRole.OWNER, members[0].role)
  }

  @Test
  fun getProjectById_shouldReturnProjectWhenExists() = runBlocking {
    val project =
        Project(
            projectId = "project2",
            name = "Test Project 2",
            description = "Description 2",
            status = ProjectStatus.IN_PROGRESS,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.ADMIN)

    val flow = repository.getProjectById("project2")
    val retrievedProject = flow.first()

    assertNotNull(retrievedProject)
    assertEquals(project.projectId, retrievedProject?.projectId)
    assertEquals(project.name, retrievedProject?.name)
    assertEquals(project.status, retrievedProject?.status)
  }

  @Test
  fun getProjectById_shouldReturnNullWhenProjectDoesNotExist() = runBlocking {
    val flow = repository.getProjectById("non_existent_project")
    val retrievedProject = flow.first()

    assertNull(retrievedProject)
  }

  @Test
  fun getProjectsForCurrentUser_shouldReturnAllProjectsForUser() = runBlocking {
    val project1 =
        Project(
            projectId = "project3",
            name = "Project 3",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    val project2 =
        Project(
            projectId = "project4",
            name = "Project 4",
            description = "",
            status = ProjectStatus.COMPLETED,
            createdBy = testUserId)

    val createFirst = repository.createProject(project1, testUserId, ProjectRole.OWNER)
    val createSecond = repository.createProject(project2, testUserId, ProjectRole.MEMBER)
    assertTrue(createFirst.isSuccess && createSecond.isSuccess)
    val flow = repository.getProjectsForCurrentUser(skipCache = false)
    val projects = flow.first()

    assertEquals(2, projects.size)
    assertTrue(projects.any { it.projectId == "project3" })
    assertTrue(projects.any { it.projectId == "project4" })
  }
  // TODO find a fix
  /*@Test
  fun getProjectsForCurrentUser_shouldReturnEmptyListWhenNoProjects() = runBlocking {
    val flow = repository.getProjectsForCurrentUser()

    // When skipCache is true and there's no data, the flow won't emit anything
    // So we expect a timeout
    var timedOut = false
    try {
      withTimeout(2000) { flow.first() }
    } catch (e: TimeoutCancellationException) {
      timedOut = true
    }

    assertTrue(timedOut)
  }*/

  @Test
  fun updateProject_shouldUpdateProjectDetails() = runBlocking {
    val project =
        Project(
            projectId = "project5",
            name = "Original Name",
            description = "Original Description",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    val updatedProject =
        project.copy(
            name = "Updated Name",
            description = "Updated Description",
            status = ProjectStatus.IN_PROGRESS)
    val result = repository.updateProject(updatedProject)

    assertTrue(result.isSuccess)

    val savedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project5")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNotNull(savedProject)
    assertEquals("Updated Name", savedProject?.name)
    assertEquals("Updated Description", savedProject?.description)
    assertEquals(ProjectStatus.IN_PROGRESS, savedProject?.status)
  }

  @Test
  fun deleteProject_shouldDeleteProjectFromFirestore() = runBlocking {
    val project =
        Project(
            projectId = "project6",
            name = "To Delete",
            description = "",
            status = ProjectStatus.ARCHIVED,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    val result = repository.deleteProject("project6")

    assertTrue(result.isSuccess)

    val deletedProject =
        FirebaseEmulator.firestore
            .collection("projects")
            .document("project6")
            .get()
            .await()
            .toObject(Project::class.java)

    assertNull(deletedProject)
  }

  @Test
  fun addMember_shouldAddMemberToProject() = runBlocking {
    val project =
        Project(
            projectId = "project7",
            name = "Member Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)

    val newUserId = "test_user_2"
    val result = repository.addMember("project7", newUserId, ProjectRole.MEMBER)

    assertTrue(result.isSuccess)

    val members = repository.getMembers("project7").first()
    assertEquals(2, members.size)
    assertTrue(members.any { it.userId == newUserId && it.role == ProjectRole.MEMBER })
  }

  @Test
  fun removeMember_shouldRemoveMemberFromProject() = runBlocking {
    val memberToRemove = "test_user_2"
    val project =
        Project(
            projectId = "project8",
            name = "Remove Member Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)
    repository.addMember("project8", memberToRemove, ProjectRole.MEMBER)

    val result = repository.removeMember("project8", memberToRemove)

    assertTrue(result.isSuccess)

    val members = repository.getMembers("project8").first()
    assertEquals(1, members.size)
    assertTrue(members.all { it.userId == testUserId })
  }

  @Test
  fun updateMemberRole_shouldUpdateMemberRole() = runBlocking {
    val memberToUpdate = "test_user_2"
    val project =
        Project(
            projectId = "project9",
            name = "Update Role Test",
            description = "",
            status = ProjectStatus.OPEN,
            createdBy = testUserId)
    repository.createProject(project, testUserId, ProjectRole.OWNER)
    repository.addMember("project9", memberToUpdate, ProjectRole.MEMBER)

    val result = repository.updateMemberRole("project9", memberToUpdate, ProjectRole.ADMIN)

    assertTrue(result.isSuccess)

    val members = repository.getMembers("project9").first()
    val updatedMember = members.find { it.userId == memberToUpdate }
    assertNotNull(updatedMember)
    assertEquals(ProjectRole.ADMIN, updatedMember?.role)

    val ownerMember = members.find { it.userId == testUserId }
    assertNotNull(ownerMember)
    assertEquals(ProjectRole.OWNER, ownerMember?.role)
  }

  @Test
  fun getProjectById_shouldHandleSnapshotListenerError(): Unit = runBlocking {
    var caughtException: Throwable? = null

    val mockFirestore = mockk<FirebaseFirestore>(relaxed = true)
    val mockAuth = mockk<FirebaseAuth>(relaxed = true)
    every { mockFirestore.collection(any()) } throws
        FirebaseFirestoreException(
            "Simulated error", FirebaseFirestoreException.Code.PERMISSION_DENIED)

    val testRepository = FirestoreProjectRepository(mockFirestore, mockAuth)
    val flow = testRepository.getProjectById("test_project")

    try {
      flow.catch { exception -> caughtException = exception }.first()
    } catch (e: Exception) {
      caughtException = e
    }

    assertNotNull(caughtException)
  }

  @Test
  fun getMembers_shouldHandleSnapshotListenerError(): Unit = runBlocking {
    var caughtException: Throwable? = null

    val mockFirestore = mockk<FirebaseFirestore>(relaxed = true)
    val mockAuth = mockk<FirebaseAuth>(relaxed = true)
    every { mockFirestore.collection(any()) } throws
        FirebaseFirestoreException(
            "Simulated error", FirebaseFirestoreException.Code.PERMISSION_DENIED)

    val testRepository = FirestoreProjectRepository(mockFirestore, mockAuth)
    val flow = testRepository.getMembers("test_project")

    try {
      flow.catch { exception -> caughtException = exception }.first()
    } catch (e: Exception) {
      caughtException = e
    }

    assertNotNull(caughtException)
  }
}
