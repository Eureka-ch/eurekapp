package ch.eureka.eurekapp.ui.meeting

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import ch.eureka.eurekapp.model.data.meeting.Meeting
import ch.eureka.eurekapp.model.data.meeting.MeetingRepository
import ch.eureka.eurekapp.model.data.meeting.MeetingRole
import ch.eureka.eurekapp.model.data.meeting.MeetingStatus
import ch.eureka.eurekapp.model.data.meeting.Participant
import kotlin.collections.filter
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOf
import org.junit.Rule
import org.junit.Test

/**
 * UI test suite for the [MeetingScreen]. This suite aims for 100% coverage by testing all UI states
 * and component variations.
 *
 * Note: This code was generated by Gemini and chatGPT
 */
class MeetingScreenTest {

  @get:Rule val composeTestRule = createComposeRule()

  // A flexible mock repository that allows us to emit specific meeting data for each test.
  private val meetingsFlow = MutableStateFlow<List<Meeting>>(emptyList())
  private val repositoryMock =
      object : FakeMeetingRepository() {
        override fun getMeetingsInProject(projectId: String): Flow<List<Meeting>> {
          return meetingsFlow
        }
      }

  /**
   * Helper function to set the content for the tests, injecting the ViewModel with the mock
   * repository.
   */
  private fun setContent() {
    val viewModel = MeetingViewModel(repositoryMock)
    composeTestRule.setContent {
      // Assuming you have a Theme wrapper, otherwise, you can remove it.
      // YourAppTheme {
      MeetingScreen(projectId = "test_project", onCreateMeeting = {}, meetingViewModel = viewModel)
      // }
    }
  }

  // --- General Screen and Tab Tests ---

  @Test
  fun screenLoadsAndDisplaysStaticContent() {
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_SCREEN_TITLE).assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_SCREEN_DESCRIPTION)
        .assertIsDisplayed()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TABS).assertIsDisplayed()
  }

  @Test
  fun upcomingMeetingsAreDisplayedByDefault() {
    meetingsFlow.value = MeetingProvider.sampleMeetings
    setContent()

    composeTestRule.waitForIdle()

    // Find an upcoming meeting's title
    val upcomingMeeting =
        MeetingProvider.sampleMeetings
            .sortedBy { m ->
              m.datetime
                  ?: m.meetingProposals
                      .filter { dtv -> dtv.votes.isNotEmpty() } // UPDATED
                      .minOfOrNull { e -> e.dateTime }
            }
            .reversed()
            .first { it.status != MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(upcomingMeeting.title).assertIsDisplayed()

    // Ensure a past meeting's title is not displayed
    val pastMeeting =
        MeetingProvider.sampleMeetings
            .sortedBy { m ->
              m.datetime
                  ?: m.meetingProposals
                      .filter { dtv -> dtv.votes.isNotEmpty() } // UPDATED
                      .minOfOrNull { e -> e.dateTime }
            }
            .reversed()
            .first { it.status == MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(pastMeeting.title).assertDoesNotExist()
  }

  @Test
  fun clickingPastTabDisplaysPastMeetings() {
    meetingsFlow.value = MeetingProvider.sampleMeetings
    setContent()

    // Switch to the PAST tab
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    // Find a past meeting's title
    val pastMeeting = MeetingProvider.sampleMeetings.first { it.status == MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(pastMeeting.title).assertIsDisplayed()

    // Ensure an upcoming meeting's title is not displayed
    val upcomingMeeting =
        MeetingProvider.sampleMeetings.first { it.status != MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(upcomingMeeting.title).assertDoesNotExist()
  }

  @Test
  fun displaysNoUpcomingMeetingsMessageWhenListIsEmpty() {
    meetingsFlow.value = emptyList()
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_UPCOMING_MEETINGS_MESSAGE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_PAST_MEETINGS_MESSAGE)
        .assertDoesNotExist()
  }

  @Test
  fun displaysNoPastMeetingsMessageWhenListIsEmpty() {
    meetingsFlow.value = emptyList()
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_PAST_MEETINGS_MESSAGE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_UPCOMING_MEETINGS_MESSAGE)
        .assertDoesNotExist()
  }

  // --- Specific Meeting Card UI State Tests ---

  @Test
  fun meetingCard_whenOpenToVotes_displaysCorrectElements() {
    // Find a specific meeting that is open for votes
    val votingMeeting = MeetingProvider.sampleMeetings.first { it.meetingID == "meet_vote_01" }
    meetingsFlow.value = listOf(votingMeeting)
    setContent()

    // Assert voting-specific elements are visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_STATUS_TEXT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DURATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.MEETING_VOTE_FOR_DATETIME_MESSAGE, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.MEETING_VOTE_FOR_FORMAT_MESSAGE, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VOTE_FOR_DATETIME_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VOTE_FOR_FORMAT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_SUMMARY_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenScheduledAndVirtual_displaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_scheduled_virtual_02" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    // Assert scheduled virtual elements are visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VOTE_FOR_DATETIME_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenScheduledAndInPerson_displaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_scheduled_inperson_03" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    // Assert scheduled in-person elements are visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenInProgressAndVirtual_displaysCorrectElements() {
    val meeting = MeetingProvider.sampleMeetings.first { it.meetingID == "meet_inprogress_06" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    // Assert in-progress virtual elements are visible (same as scheduled)
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenInProgressAndInPerson_displaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_inprogress_inperson_15" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    // Assert in-progress in-person elements are visible (same as scheduled)
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenCompletedAndVirtual_displaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_completed_virtual_05" }
    // We need to switch to the "PAST" tab to see completed meetings
    meetingsFlow.value = listOf(meeting)
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    // Assert completed elements are visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_SUMMARY_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_TRANSCRIPT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert the link is hidden for completed virtual meetings, as per the code
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCard_whenCompletedAndInPerson_displaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_completed_inperson_04" }
    meetingsFlow.value = listOf(meeting)
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    // Assert completed elements are visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_SUMMARY_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_TRANSCRIPT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    // Assert other elements are NOT visible
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }
}

/**
 * A basic fake implementation of [MeetingRepository] for UI tests. We only need to override the
 * method used by the ViewModel.
 */
open class FakeMeetingRepository : MeetingRepository {
  override fun getMeetingsInProject(projectId: String): Flow<List<Meeting>> = flowOf(emptyList())

  override fun getMeetingById(projectId: String, meetingId: String): Flow<Meeting?> = flow { null }

  override fun getMeetingsForTask(projectId: String, taskId: String): Flow<List<Meeting>> = flow {
    emptyList<Meeting>()
  }

  override fun getMeetingsForCurrentUser(
      projectId: String,
      skipCache: Boolean
  ): Flow<List<Meeting>> = flow { emptyList<Meeting>() }

  override suspend fun createMeeting(
      meeting: Meeting,
      creatorId: String,
      creatorRole: MeetingRole
  ): Result<String> = runCatching { "url" }

  override suspend fun updateMeeting(meeting: Meeting): Result<Unit> = runCatching {}

  override suspend fun deleteMeeting(projectId: String, meetingId: String): Result<Unit> =
      runCatching {}

  override fun getParticipants(projectId: String, meetingId: String): Flow<List<Participant>> =
      flow {
        emptyList<Participant>()
      }

  override suspend fun addParticipant(
      projectId: String,
      meetingId: String,
      userId: String,
      role: MeetingRole
  ): Result<Unit> = runCatching {}

  override suspend fun removeParticipant(
      projectId: String,
      meetingId: String,
      userId: String
  ): Result<Unit> = runCatching {}

  override suspend fun updateParticipantRole(
      projectId: String,
      meetingId: String,
      userId: String,
      role: MeetingRole
  ): Result<Unit> = runCatching {}
}
