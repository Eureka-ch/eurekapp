/* Portions of this file were written with the help of Gemini.*/
package ch.eureka.eurekapp.ui.meeting

import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.rule.GrantPermissionRule
import ch.eureka.eurekapp.model.data.meeting.Meeting
import ch.eureka.eurekapp.model.data.meeting.MeetingRepository
import ch.eureka.eurekapp.model.data.meeting.MeetingRole
import ch.eureka.eurekapp.model.data.meeting.MeetingStatus
import ch.eureka.eurekapp.model.data.meeting.Participant
import kotlin.collections.filter
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOf
import org.junit.Assert.assertEquals
import org.junit.Rule
import org.junit.Test

/**
 * UI test suite for the [MeetingScreen]. This suite aims for 100% coverage by testing all UI states
 * and component variations.
 *
 * Note: This code was generated by Gemini and chatGPT
 */
class MeetingScreenTest {

  @get:Rule
  val permissionRule: GrantPermissionRule =
      GrantPermissionRule.grant(
          android.Manifest.permission.READ_CALENDAR, android.Manifest.permission.WRITE_CALENDAR)

  @get:Rule val composeTestRule = createComposeRule()

  private val meetingsFlow = MutableStateFlow<List<Meeting>>(emptyList())
  private var testUserId: String? = MeetingProvider.sampleMeetings.first().createdBy

  private val repositoryMock =
      object : FakeMeetingRepository() {
        var updateMeetingCallCount = 0
        var updatedMeeting: Meeting? = null

        override fun getMeetingsInProject(projectId: String): Flow<List<Meeting>> {
          return meetingsFlow
        }

        override suspend fun updateMeeting(meeting: Meeting): Result<Unit> {
          updateMeetingCallCount++
          updatedMeeting = meeting
          val updatedList =
              meetingsFlow.value.filter { it.meetingID != meeting.meetingID } +
                  meeting.copy(status = MeetingStatus.SCHEDULED, meetingProposals = emptyList())
          meetingsFlow.value = updatedList
          return Result.success(Unit)
        }
      }

  private fun setContent() {
    val viewModel = MeetingViewModel(repositoryMock) { testUserId }
    composeTestRule.setContent {
      MeetingScreen(
          meetingViewModel = viewModel,
          config = MeetingScreenConfig(projectId = "test_project", onCreateMeeting = {}))
    }
  }

  @Test
  fun screenLoadsAndDisplaysStaticContent() {
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_SCREEN_TITLE).assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_SCREEN_DESCRIPTION)
        .assertIsDisplayed()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TABS).assertIsDisplayed()
  }

  @Test
  fun upcomingMeetingsAreDisplayedByDefault() {
    meetingsFlow.value = MeetingProvider.sampleMeetings
    setContent()

    composeTestRule.waitForIdle()

    val upcomingMeeting =
        MeetingProvider.sampleMeetings
            .sortedBy { m ->
              m.datetime
                  ?: m.meetingProposals
                      .filter { dtv -> dtv.votes.isNotEmpty() }
                      .minOfOrNull { e -> e.dateTime }
            }
            .reversed()
            .first { it.status != MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(upcomingMeeting.title).assertIsDisplayed()

    val pastMeeting =
        MeetingProvider.sampleMeetings
            .sortedBy { m ->
              m.datetime
                  ?: m.meetingProposals
                      .filter { dtv -> dtv.votes.isNotEmpty() }
                      .minOfOrNull { e -> e.dateTime }
            }
            .reversed()
            .first { it.status == MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(pastMeeting.title).assertDoesNotExist()
  }

  @Test
  fun clickingPastTabDisplaysPastMeetings() {
    meetingsFlow.value = MeetingProvider.sampleMeetings
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    val pastMeeting = MeetingProvider.sampleMeetings.first { it.status == MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(pastMeeting.title).assertIsDisplayed()

    val upcomingMeeting =
        MeetingProvider.sampleMeetings.first { it.status != MeetingStatus.COMPLETED }
    composeTestRule.onNodeWithText(upcomingMeeting.title).assertDoesNotExist()
  }

  @Test
  fun displaysNoUpcomingMeetingsMessageWhenListIsEmpty() {
    meetingsFlow.value = emptyList()
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_UPCOMING_MEETINGS_MESSAGE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_PAST_MEETINGS_MESSAGE)
        .assertDoesNotExist()
  }

  @Test
  fun displaysNoPastMeetingsMessageWhenListIsEmpty() {
    meetingsFlow.value = emptyList()
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_PAST_MEETINGS_MESSAGE)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.NO_UPCOMING_MEETINGS_MESSAGE)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenOpenToVotesDisplaysCorrectElements() {
    val votingMeeting = MeetingProvider.sampleMeetings.first { it.meetingID == "meet_vote_01" }
    meetingsFlow.value = listOf(votingMeeting)
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_STATUS_TEXT, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DURATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.MEETING_VOTE_FOR_DATETIME_MESSAGE, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.MEETING_VOTE_FOR_FORMAT_MESSAGE, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.VOTE_FOR_MEETING_PROPOSAL_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenScheduledAndVirtualDisplaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_scheduled_virtual_02" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(
            MeetingScreenTestTags.VOTE_FOR_MEETING_PROPOSAL_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenScheduledAndInPersonDisplaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_scheduled_inperson_03" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenInProgressAndVirtualDisplaysCorrectElements() {
    val meeting = MeetingProvider.sampleMeetings.first { it.meetingID == "meet_inprogress_06" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenInProgressAndInPersonDisplaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_inprogress_inperson_15" }
    meetingsFlow.value = listOf(meeting)
    setContent()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenCompletedAndVirtualDisplaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_completed_virtual_05" }
    meetingsFlow.value = listOf(meeting)
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_TRANSCRIPT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LINK, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.JOIN_MEETING_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun meetingCardWhenCompletedAndInPersonDisplaysCorrectElements() {
    val meeting =
        MeetingProvider.sampleMeetings.first { it.meetingID == "meet_completed_inperson_04" }
    meetingsFlow.value = listOf(meeting)
    setContent()
    composeTestRule.onNodeWithTag(MeetingScreenTestTags.MEETING_TAB_PAST).performClick()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_DATETIME, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.MEETING_LOCATION, useUnmergedTree = true)
        .assertIsDisplayed()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.VIEW_TRANSCRIPT_BUTTON, useUnmergedTree = true)
        .assertIsDisplayed()

    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.DIRECTIONS_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
    composeTestRule
        .onNodeWithTag(MeetingScreenTestTags.RECORD_BUTTON, useUnmergedTree = true)
        .assertDoesNotExist()
  }

  @Test
  fun closeVotesButtonIsDisplayedForCreatorWhenMeetingIsOpenToVotes() {
    val votingMeeting =
        MeetingProvider.sampleMeetings.first { it.status == MeetingStatus.OPEN_TO_VOTES }
    testUserId = votingMeeting.createdBy
    meetingsFlow.value = listOf(votingMeeting)
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.CLOSE_VOTES_BUTTON).assertIsDisplayed()
  }

  @Test
  fun closeVotesButtonIsNotDisplayedForNonCreator() {
    val votingMeeting =
        MeetingProvider.sampleMeetings.first { it.status == MeetingStatus.OPEN_TO_VOTES }
    testUserId = "some_other_user_id"
    meetingsFlow.value = listOf(votingMeeting)
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.CLOSE_VOTES_BUTTON).assertDoesNotExist()
  }

  @Test
  fun closeVotesButtonIsNotDisplayedForScheduledMeetingEvenForCreator() {
    val scheduledMeeting =
        MeetingProvider.sampleMeetings.first { it.status == MeetingStatus.SCHEDULED }
    testUserId = scheduledMeeting.createdBy
    meetingsFlow.value = listOf(scheduledMeeting)
    setContent()

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.CLOSE_VOTES_BUTTON).assertDoesNotExist()
  }

  @Test
  fun clickingCloseVotesButtonCallsViewModel() {
    val votingMeeting = MeetingProvider.sampleMeetings.first { it.meetingID == "meet_vote_01" }
    testUserId = votingMeeting.createdBy
    meetingsFlow.value = listOf(votingMeeting)
    setContent()

    assertEquals(0, repositoryMock.updateMeetingCallCount)

    composeTestRule.onNodeWithTag(MeetingScreenTestTags.CLOSE_VOTES_BUTTON).performClick()

    composeTestRule.waitForIdle()

    assertEquals(1, repositoryMock.updateMeetingCallCount)
    assertEquals(MeetingStatus.SCHEDULED, repositoryMock.updatedMeeting?.status)
    assertEquals(votingMeeting.meetingID, repositoryMock.updatedMeeting?.meetingID)
  }
}

open class FakeMeetingRepository : MeetingRepository {
  override fun getMeetingsInProject(projectId: String): Flow<List<Meeting>> = flowOf(emptyList())

  override fun getMeetingById(projectId: String, meetingId: String): Flow<Meeting?> = flow { null }

  override fun getMeetingsForTask(projectId: String, taskId: String): Flow<List<Meeting>> = flow {
    emptyList<Meeting>()
  }

  override fun getMeetingsForCurrentUser(
      projectId: String,
      skipCache: Boolean
  ): Flow<List<Meeting>> = flow { emptyList<Meeting>() }

  override suspend fun createMeeting(
      meeting: Meeting,
      creatorId: String,
      creatorRole: MeetingRole
  ): Result<String> = runCatching { "url" }

  override suspend fun updateMeeting(meeting: Meeting): Result<Unit> = runCatching {}

  override suspend fun deleteMeeting(projectId: String, meetingId: String): Result<Unit> =
      runCatching {}

  override fun getParticipants(projectId: String, meetingId: String): Flow<List<Participant>> =
      flow {
        emptyList<Participant>()
      }

  override suspend fun addParticipant(
      projectId: String,
      meetingId: String,
      userId: String,
      role: MeetingRole
  ): Result<Unit> = runCatching {}

  override suspend fun removeParticipant(
      projectId: String,
      meetingId: String,
      userId: String
  ): Result<Unit> = runCatching {}

  override suspend fun updateParticipantRole(
      projectId: String,
      meetingId: String,
      userId: String,
      role: MeetingRole
  ): Result<Unit> = runCatching {}
}
